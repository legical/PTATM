import matplotlib.pyplot as plt
import statsmodels.tsa.stattools as stattools
from abc import abstractmethod
from scipy.stats import gumbel_r, genpareto, cramervonmises

class EVT:
    def __init__(self, evt_class) -> None:
        self.evt_class = evt_class
        # A list saves raw samples.
        self.raw_data = list()

        # Following attributes are generated by function fit from raw data.
        # Save kpss result.
        self.kpss_result = None
        # Save bds result.
        self.bds_result = None
        # Save cvm result.
        self.cvm_result = None
        # A list saves extreme samples.
        self.ext_data = list()
        # A evt function with arguments setted.
        self.evt_func = None
        self.err_msg = str()

    @abstractmethod
    def fit(self) -> bool:
        # pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        return None

    # Modifier.
    def set_rawdata(self, raw_data: list[float]):
        self.raw_data = raw_data.copy()
        return self

    # Util.

    # Return a pwcet with exceedance probability(exceed_prob).
    def pwcet(self, exceed_prob: float) -> float:
        return self.evt_func.isf(exceed_prob)

    # Plot sf, where sf = 1 - cdf.
    def plot_sf(self):
        pass

    # Stationarity test for raw data.
    def kpss(self):
        return stattools.kpss(self.raw_data)

    # Independent and identically distributed test for raw data.
    def bds(self):
        return stattools.bds(self.raw_data)

    # Long range dependence test.
    def lrd(self):
        # TODO: fill this function.
        pass

    # Test for goodness of fit of a cumulative distribution function.
    def cvm(self):
        return cramervonmises(self.ext_data, self.evt_func.cdf)

class GEV(EVT):

    MIN_NRSAMPLE = 2

    def __init__(self, gev_class) -> None:
        super().__init__(gev_class)

    @staticmethod
    def BM(data: list[float], bs: int) -> list[float]:
        ext_vals, nr_sample = list(), len(data)
        for i in range(nr_sample//bs + 1):
            s = i * bs
            e = s + bs
            if s >= nr_sample:
                break
            ext_vals.append(max(data[s:] if e > nr_sample else data[s:e]))
        return ext_vals

    def fit(self) -> bool:
        # pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        if len(self.raw_data) < GEV.MIN_NRSAMPLE:
            self.err_msg = "Too few samples[%d] to fit." % len(self.raw_data)
            return False

        # Use BM to filter ext_data.
        max_bs = len(self.raw_data) // GEV.MIN_NRSAMPLE
        self.ext_data = GEV.BM(self.raw_data, max_bs)

        # TODO: pass test.

        # Fit args for evt class and build evt function.
        loc, scale = self.evt_class.fit(self.ext_data)
        self.evt_func = self.evt_class(loc=loc, scale=scale)
        return True

class GPD(EVT):

    MIN_NRSAMPLE = 1

    def __init__(self, gpd_class) -> None:
        super().__init__(gpd_class)

    @staticmethod
    def POT(data: list[float], nr_ext: int) -> list[float]:
        nr_sample = len(data)
        if nr_ext < 0 or nr_ext >= nr_sample:
            return data[:]
        data = data.copy()
        data.sort()
        return data[-nr_ext:]

    def fit(self) -> bool:
        # pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        if len(self.raw_data) < GPD.MIN_NRSAMPLE:
            self.err_msg = "Too few samples[%d] to fit." % len(self.raw_data)
            return False

        # Use POT to filter ext_data.
        self.ext_data = GPD.POT(self.raw_data, 4)

        # TODO: pass test.

        # Fit args for evt class and build evt function.
        # Here we fix c(f0) = 0 to force an exponential distribution fit.
        c, loc, scale = self.evt_class.fit(self.ext_data, f0=0)
        self.evt_func = self.evt_class(c=c, loc=loc, scale=scale)

        return True

class Gumbel(GEV):
    def __init__(self) -> None:
        super().__init__(gumbel_r)

class Pareto(GPD):
    def __init__(self) -> None:
        super().__init__(genpareto)

class LinearCombinedEVT:
    def __init__(self) -> None:
        # A dict maps evt function to it's weight.
        self.weighted_evtfunc = dict()

    def addSubDistribution(self, evt_func, weight: int = 1):
        self.weighted_evtfunc.setdefault(evt_func, 0)
        self.weighted_evtfunc[evt_func] += weight

    # Plot sf, where sf = 1 - cdf.
    def plot_sf(self):
        pass

    # Return a pwcet with exceedance probability(exceed_prob).
    @abstractmethod
    def pwcet(self, exceed_prob: float) -> float:
        pass


class PositiveLinearGumbel(LinearCombinedEVT):
    @abstractmethod
    # Return a pwcet with exceedance probability(exceed_prob).
    def pwcet(self, exceed_prob: float) -> float:
        pass

class PositiveLinearPareto(LinearCombinedEVT):
    @abstractmethod
    # Return a pwcet with exceedance probability(exceed_prob).
    def pwcet(self, exceed_prob: float) -> float:
        pass
