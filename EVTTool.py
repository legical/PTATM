from functools import reduce
import matplotlib.pyplot as plt
import statsmodels.tsa.stattools as stattools
from abc import abstractmethod
from scipy.stats import gumbel_r, genpareto, cramervonmises

class ExtremeDistribution:
    @abstractmethod
    # Return a value with exceedance probability(exceed_prob).
    def isf(self, exceed_prob: float) -> float:
        pass

    @abstractmethod
    def to_string(self) -> str:
        pass

    # Plot sf, where sf = 1 - cdf.
    def plot_sf(self):
        pass

class EVT(ExtremeDistribution):
    def __init__(self, evt_class) -> None:
        self.evt_class = evt_class
        # A list saves raw samples.
        self.raw_data = list()

        # Following attributes are generated by function fit from raw data.
        # Save kpss result.
        self.kpss_result = None
        # Save bds result.
        self.bds_result = None
        # Save cvm result.
        self.cvm_result = None
        # A list saves extreme samples.
        self.ext_data = list()
        # A evt function with arguments setted.
        self.evt_func = None
        self.err_msg = str()

    @abstractmethod
    def fit(self) -> bool:
        # pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        return None

    # Modifier.
    def set_rawdata(self, raw_data: list[float]):
        self.raw_data = raw_data.copy()
        return self

    # Util.
    def isf(self, exceed_prob: float) -> float:
        return self.evt_func.isf(exceed_prob)

    def to_string(self) -> str:
        return str(self.evt_class) + ":" + str(self.evt_func.kwds)

    # Stationarity test for raw data.
    def kpss(self):
        return stattools.kpss(self.raw_data)

    # Independent and identically distributed test for raw data.
    def bds(self):
        return stattools.bds(self.raw_data)

    # Long range dependence test.
    def lrd(self):
        # TODO: fill this function.
        pass

    # Test for goodness of fit of a cumulative distribution function.
    def cvm(self):
        return cramervonmises(self.ext_data, self.evt_func.cdf)

class GEV(EVT):

    MIN_NRSAMPLE = 2

    def __init__(self, gev_class) -> None:
        super().__init__(gev_class)

    @staticmethod
    def BM(data: list[float], bs: int) -> list[float]:
        ext_vals, nr_sample = list(), len(data)
        for i in range(nr_sample//bs + 1):
            s = i * bs
            e = s + bs
            if s >= nr_sample:
                break
            ext_vals.append(max(data[s:] if e > nr_sample else data[s:e]))
        return ext_vals

    def fit(self) -> bool:
        # Pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        if len(self.raw_data) < GEV.MIN_NRSAMPLE:
            self.err_msg = "Too few samples[%d] to fit.\n" % len(self.raw_data)
            return False
        if max(self.raw_data) <= 0:
            self.err_msg = "Max(self.raw_data)[%f]<=0.\n" % max(self.raw_data)
            return False

        # Use BM to filter ext_data.
        max_bs = len(self.raw_data) // GEV.MIN_NRSAMPLE
        self.ext_data = GEV.BM(self.raw_data, max_bs)

        # TODO: pass test.

        # Fit args for evt class and build evt function.
        loc, scale = self.evt_class.fit(self.ext_data)
        self.evt_func = self.evt_class(loc=loc, scale=scale)
        return True

class GPD(EVT):

    MIN_NRSAMPLE = 1

    def __init__(self, gpd_class) -> None:
        super().__init__(gpd_class)

    @staticmethod
    def POT(data: list[float], nr_ext: int) -> list[float]:
        nr_sample = len(data)
        if nr_ext < 0 or nr_ext >= nr_sample:
            return data[:]
        data = data.copy()
        data.sort()
        return data[-nr_ext:]

    def fit(self) -> bool:
        # Pick raw samples until we pass kpss,bds,lrd test -> pick extreme value & EVT fit until we pass cvm test.
        if len(self.raw_data) < GPD.MIN_NRSAMPLE:
            self.err_msg = "Too few samples[%d] to fit.\n" % len(self.raw_data)
            return False
        if max(self.raw_data) <= 0:
            self.err_msg = "Max(self.raw_data)[%f]<=0.\n" % max(self.raw_data)
            return False

        # Use POT to filter ext_data.
        self.ext_data = GPD.POT(self.raw_data, 4)

        # TODO: pass test.

        # Fit args for evt class and build evt function.
        # Here we fix c(f0) = 0 to force an exponential distribution fit.
        c, loc, scale = self.evt_class.fit(self.ext_data, f0=0)
        self.evt_func = self.evt_class(c=c, loc=loc, scale=scale)

        return True

class Gumbel(GEV):
    def __init__(self) -> None:
        super().__init__(gumbel_r)

    def to_string(self) -> str:
        kwds = self.evt_func.kwds
        return "Gumbel(loc=%s,scale=%s)" % (str(round(kwds["loc"], 4)), str(round(kwds["scale"], 4)))

class Pareto(GPD):
    def __init__(self) -> None:
        super().__init__(genpareto)

    def to_string(self) -> str:
        kwds = self.evt_func.kwds
        return "Pareto(c=%s, loc=%s,scale=%s)" % (str(round(kwds["c"], 4)), str(round(kwds["loc"], 4)), str(round(kwds["scale"], 4)))

class LinearCombinedEVT(ExtremeDistribution):
    def __init__(self) -> None:
        # A dict maps evt object to it's weight.
        self.weighted_evtobject = dict()

    @abstractmethod
    def add(self, evt_object: EVT, weight: int) -> bool:
        pass

    def to_string(self) -> str:
        jointfunc = lambda k1, k2: str(self.weighted_evtobject[k1]) + '*' + k1.to_string() + ' + ' + str(self.weighted_evtobject[k2]) + '*' + k2.to_string()
        return reduce(jointfunc, self.weighted_evtobject)

class PositiveLinearGumbel(LinearCombinedEVT):
    def __init__(self) -> None:
        super().__init__()

    def add(self, evt_object: Gumbel, weight: int = 1) -> bool:
        if not isinstance(evt_object, Gumbel) or weight < 0:
            return False
        if weight > 0:
            self.weighted_evtobject.setdefault(evt_object, 0)
            self.weighted_evtobject[evt_object] += weight
        return True

    # Return a value with exceedance probability(exceed_prob).
    def isf(self, exceed_prob: float) -> float:
        ans = 0.0
        for evt_object, weight in self.weighted_evtobject.items():
            ans += weight * evt_object.isf(exceed_prob)
        return ans

class PositiveLinearPareto(LinearCombinedEVT):
    def __init__(self) -> None:
        super().__init__()

    def add(self, evt_object: Pareto, weight: int = 1) -> bool:
        if not isinstance(evt_object, Pareto) or weight < 0:
            return False
        if weight > 0:
            self.weighted_evtobject.setdefault(evt_object, 0)
            self.weighted_evtobject[evt_object] += weight
        return True
        
    # Return a value with exceedance probability(exceed_prob).
    def isf(self, exceed_prob: float) -> float:
        ans = 0.0
        for evt_object, weight in self.weighted_evtobject.items():
            ans += weight * evt_object.isf(exceed_prob)
        return ans
